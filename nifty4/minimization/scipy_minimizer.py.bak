# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright(C) 2013-2017 Max-Planck-Society
#
# NIFTy is being developed at the Max-Planck-Institut fuer Astrophysik
# and financially supported by the Studienstiftung des deutschen Volkes.

from __future__ import division
from .minimizer import Minimizer
from ..field import Field
from .. import dobj


class ScipyMinimizer(Minimizer):
    """Scipy-based minimizer

    Parameters
    ----------
    controller : IterationController
        Object that decides when to terminate the minimization.
    """

    def __init__(self, controller, method="trust-ncg"):
        super(ScipyMinimizer, self).__init__()
        if not dobj.is_numpy():
            raise NotImplementedError
        self._controller = controller
        self._method = method

    def __call__(self, energy):
        class _MinimizationDone:
            pass

        class _MinHelper(object):
            def __init__(self, controller, energy):
                self._controller = controller
                self._energy = energy
                self._domain = energy.position.domain

            def _update(self, x):
                pos = Field(self._domain, x.reshape(self._domain.shape))
                if (pos.val != self._energy.position.val).any():
                    self._energy = self._energy.at(pos)
                    status = self._controller.check(self._energy)
                    if status != self._controller.CONTINUE:
                        raise _MinimizationDone

            def fun(self, x):
                self._update(x)
                return self._energy.value

            def jac(self, x):
                self._update(x)
                return self._energy.gradient.val.reshape(-1)

            def hessp(self, x, p):
                self._update(x)
                vec = Field(self._domain, p.reshape(self._domain.shape))
                res = self._energy.curvature(vec)
                return res.val.reshape(-1)

        import scipy.optimize as opt
        status = self._controller.start(energy)
        if status != self._controller.CONTINUE:
            return energy, status
        hlp = _MinHelper(self._controller, energy)
        options = {'disp': False,
                   'xtol': 1e-15,
                   'eps': 1.4901161193847656e-08,
                   'return_all': False,
                   'maxiter': None}
        options = {'disp': False,
                   'ftol': 1e-15,
                   'gtol': 1e-15,
                   'eps': 1.4901161193847656e-08}
        try:
            opt.minimize(hlp.fun, energy.position.val.reshape(-1),
                         method=self._method, jac=hlp.jac,
                         hessp=hlp.hessp,
                         options=options)
        except _MinimizationDone:
            energy = hlp._energy
            status = self._controller.check(energy)
            return energy, status
        return hlp._energy, self._controller.ERROR
